
################################################################################
date : 24 : Oct: 2025

Running RunCode.sh 
	it runs: 
		BaseCode_Mqtt_Collector.py
		sensor_publisher.py 
		sensor_subscriber.py
		sensor_data_infinite.py  

	Collects Logs at:
		mqtt_capture
		tcpdump_data  
		pcap_captures  
		
Learning points:

Brokers ip address hsould be  
	server = net.addHost('server', ip='10.0.0.100/8')
	BROKER_IP = "10.0.0.100"
mosquitto.conf file should have  
		
		
		
################################################################################

summarize **today’s implementation** of an MQTT-based IoT sensor network in **Mininet with SDN**, step by step:

---

## **1. Network Setup (Mininet + SDN)**

* **Topology**:

  * **Hosts**: `emergency`, `monitoring`, `server`
  * **Switch**: `s1` (OVS switch)
  * **Controller**: `c0` (default Mininet Controller)
* **Links**: Bandwidth-limited links (10 Mbps) between hosts and switch.
* **IP Addresses**:

  * emergency: `10.0.0.10/8`
  * monitoring: `10.0.0.20/8`
  * server: `10.0.0.100/8`

**Why**: Simulate a small SDN-controlled IoT network for sensor data traffic.

---

## **2. MQTT Setup**

* **Broker**:

  * Runs on the `server` host.
  * Custom Mosquitto configuration: `listener 1883 0.0.0.0` (accept connections from all hosts in Mininet).
  * Verified broker is listening using `netstat` and connectivity from emergency host (`nc -zv 10.0.0.100 1883`).

* **Subscriber**:

  * Runs on `server`, subscribes to `sensors/#` topics.
  * Logs captured in `/tmp/sensor_subscriber.log`.

* **Publishers**:

  * `emergency` host → topic: `sensors/emergency`
  * `monitoring` host → topic: `sensors/monitoring`
  * Logs captured individually in `/tmp/sensor_publisher_<host>.log`.

**Why**: Demonstrates application-layer data generation in hosts while the SDN network handles routing and forwarding.

---

## **3. Traffic Capture (tcpdump / PCAPs)**

* **Hosts**: Captured all non-loopback interfaces → files: `OUTPUT_DIR/<host>_<intf>_<timestamp>.pcap`
* **Switch**: Captured all interfaces → option to merge switch PCAPs (`MERGE_SWITCH_PCAPS=True`)
* **Controller**: Captured traffic on `any` interface

**Why**: Observe packet flows, measure metrics (PDR, bandwidth, latency), and analyze SDN behavior.

---

## **4. Flow of Data in the Network**

1. Publishers on `emergency` and `monitoring` generate sensor data (application layer).
2. Data is sent via **MQTT over TCP** to the broker on the `server` host.
3. SDN switch (`s1`) forwards packets according to default flow rules managed by `c0` controller.
4. Subscriber on `server` receives messages, logs them.

**Key points**:

* Hosts have an **application layer** (MQTT publisher).
* Switch & controller perform **network forwarding**.
* Server acts as **broker + subscriber**.
* TCP/IP + MQTT traffic can be analyzed via PCAPs.

---

## **5. Observations Possible from This Setup**

* **Packet flow**: emergency → server, monitoring → server
* **QoS metrics**:

  * Packet delivery ratio (PDR)
  * Bandwidth utilization per host and switch
  * Latency (publish → subscribe)
* **Priority Analysis**: For now, all traffic is equal (no prioritization yet).
* **Logging**: MQTT traffic logs + PCAPs for deeper packet inspection.

---

## **6. Optional Features**

* Merge switch PCAPs (`mergecap`)
* Separate PCAPs for hosts, switch, controller
* Logging of publishers/subscriber
* Delays can be added for testing congestion or QoS policies

---

## **7. Summary Diagram / Flow**

```
+------------------+         +-----------------+          +----------------+
|  Emergency Host  |         | Monitoring Host |          |    Server      |
|  Publisher App   |----+--> |  Publisher App  | --+-->  |  MQTT Broker   |
|                  |    |    |                 |  |     |  Subscriber    |
+------------------+    |    +-----------------+  |     +----------------+
                        |                         |
                        v                         v
                     +------------------------------+
                     |            s1 (OVS)          |
                     | SDN Switch: forwards packets |
                     +------------------------------+
                               ^
                               |
                           +--------+
                           |  c0    |
                           |Controller|
                           +--------+
```

**Legend**:

* Hosts → Application layer (MQTT publisher)
* Switch → Forwarding plane
* Controller → SDN control plane
* Server → Broker + Subscriber

---

This implementation gives you **end-to-end IoT traffic flow in an SDN-controlled network** with logging and packet capture for later analysis.

---

If you want, I can also make a **step-by-step flowchart of the Python code itself**, showing how each module runs and interacts (publisher → broker → subscriber → tcpdump). That will help for documentation and understanding.

Do you want me to make that flowchart?

